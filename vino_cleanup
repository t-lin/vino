#!/usr/bin/env python

# Copyright (c) 2014 University of Toronto
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
# implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# vim: tabstop=4 shiftwidth=4 softtabstop=4 expandtab

import os
import sys

import novaclient.v1_1.client as nclient
from novaclient import exceptions

import config2 as config

DELETE_OPTIONS = ('yes', 'no', 'yesall', 'noall')
DELETE_CHOICE = ""

# Delete VMs passed in from list
# Returns list of deleted VMs in format of:
#   [(VM UUID, VM NAME), (...), ...)
def delete_vms(nova, oldVMList):
    global DELETE_OPTIONS, DELETE_CHOICE

    oldVMIDs = [vm[0] for vm in oldVMList]
    region = nova.client.region_name
    deleted = []

    for s in nova.servers.list():
        if s.id in oldVMIDs:
            while DELETE_CHOICE not in DELETE_OPTIONS:
                print "\nWARNING: Found a pre-existing VM created by ViNO (%s) in region %s. Delete it?" % (s.name, region)
                DELETE_CHOICE = raw_input("         [yes / no / yesall / noall] => ")
                DELETE_CHOICE = DELETE_CHOICE.lower()
                if DELETE_CHOICE not in DELETE_OPTIONS:
                    print "Invalid option, try again."

            if DELETE_CHOICE in ("yes", "yesall"):
                print "Deleting %s in %s" % (s.name, region)
                s.delete()
                deleted.append((s.id, s.name))

            if DELETE_CHOICE in ("yes", "no"):
                DELETE_CHOICE = "" # Reset for next loop

    return deleted

# Updates the ViNO node file (assumes it already exists)
# If delete = False (default), nodes from nodeList are appended
# If delete = True, nodes from nodeList are removed (if found in file)
#
# Assumes nodeList is format of [(VM UUID, VM NAME), (...), ...)
def update_vino_node_file(nodeList, region, delete = False):
    homePath = os.environ['HOME']

    try:
        if delete:
            nodeFile = open(homePath + '/.vino', 'r')
            lines = nodeFile.readlines()
            nodeFile.close()

            vmIDsToDelete = [vm[0] for vm in nodeList]
            nodeFile = open(homePath + '/.vino', 'w')
            for line in lines:
                reg, tenant, vmUUID, vmName = line.split()
                if vmUUID not in vmIDsToDelete:
                    nodeFile.write(line)

            nodeFile.close()
        else:
            # Append to file
            nodeFile = open(homePath + '/.vino', 'a')
            for node in nodeList:
                outLine = "%s %s %s %s\n" % (region, config.tenant_name, node[0], node[1])
                nodeFile.write(outLine)

            nodeFile.close()
    except:
        import traceback; traceback.print_exc()
        sys.exit(1)

# Returns dictionary of existing VMs from ViNO node file
# Format of returned dict:
#   { "regionName" : [(VM UUID, VM NAME), (...), ...], ... }
# Default location for file: ~/.vino
#
# Can filter results via input parameter List 'relevantRegions'
#   - If this is None, then don't filter (i.e. return all)
def get_vino_node_file(relevantRegions = None):
    old_nodes = {}

    homePath = os.environ['HOME']
    try:
        nodeFile = open(homePath + '/.vino', 'r')
    except IOError as e:
        if "No such file or directory" not in e.strerror:
            raise
        else:
            # Create file
            nodeFile = open(homePath + '/.vino', 'w')
            nodeFile.close()
            return {}

    # Node file format:
    #   <REGION> <TENANT NAME> <VM UUID> <VM NAME>
    # NOTE: Currently we do not support multi-tenant overlay, the tenant name
    #       is just used to know which items to skip
    for line in nodeFile:
        try:
            reg, tenant, vmUUID, vmName = line.split()
            if relevantRegions is None or reg in relevantRegions:
                # Lists returned by ref, so no need to re-store
                vmList = old_nodes.setdefault(reg, [])
                if tenant == config.tenant_name:
                    vmList.append((vmUUID, vmName))
        except:
            import traceback; traceback.print_exc()
            print line
            sys.exit(1)

    nodeFile.close()
    return old_nodes

if __name__ == "__main__":
    # Read file to find any existing VMs
    oldVMs = get_vino_node_file()

    regions = oldVMs.keys()

    # Create a nova and neutron clients per region
    reg2nova = {}
    reg2neutron = {}
    for reg in regions:
        reg2nova[reg] = nclient.Client(config.username, config.password, config.tenant_name, config.auth_url, region_name=reg, no_cache=True)

    #Delete any existing VMs
    print "\n===================="
    print "Checking for VMs from previous run(s)..."
    print "===================="
    for reg in oldVMs.keys():
        deleted = delete_vms(reg2nova[reg], oldVMs[reg])
        update_vino_node_file(deleted, reg, delete = True)

